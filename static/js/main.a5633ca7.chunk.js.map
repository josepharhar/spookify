{"version":3,"sources":["../../spotify-web-api-node/src/base-request.js","../../spotify-web-api-node/src/client.js","../../spotify-web-api-node/src/spotify-web-api.js","../../spotify-web-api-node/src/authentication-request.js","../../spotify-web-api-node/src/webapi-request.js","../../spotify-web-api-node/src/http-manager.js","../../spotify-web-api-node/src/response-error.js","SplitWidget.tsx","Recipe.ts","Api.ts","RecipeEditor.tsx","RecipeRunner.ts","App.tsx","Login.tsx","index.tsx"],"names":["Request","builder","Error","this","host","port","scheme","queryParameters","bodyParameters","headers","path","prototype","_getter","key","getHost","getPort","getScheme","getPath","getQueryParameters","getBodyParameters","getHeaders","getURI","uri","getURL","getQueryParameterString","Object","keys","filter","undefined","map","join","execute","method","callback","_self","Promise","resolve","reject","error","result","Builder","_setter","value","withHost","withPort","withScheme","withPath","_assigner","i","arguments","length","_assign","withQueryParameters","withBodyParameters","withHeaders","withAuth","accessToken","Authorization","src","obj","Array","isArray","assign","build","module","exports","require","WebApiRequest","HttpManager","SpotifyWebApi","credentials","_credentials","setCredentials","hasOwnProperty","getCredentials","resetCredentials","setClientId","clientId","_setCredential","setClientSecret","clientSecret","setAccessToken","setRefreshToken","refreshToken","setRedirectURI","redirectUri","getRedirectURI","_getCredential","getClientId","getClientSecret","getAccessToken","getRefreshToken","resetClientId","_resetCredential","resetClientSecret","resetAccessToken","resetRefreshToken","resetRedirectURI","credentialKey","getTrack","trackId","options","get","getTracks","trackIds","ids","getAlbum","albumId","getAlbums","albumIds","getArtist","artistId","getArtists","artistIds","search","query","types","type","q","searchAlbums","searchArtists","searchTracks","searchPlaylists","getArtistAlbums","getAlbumTracks","getArtistTopTracks","country","getArtistRelatedArtists","getUser","userId","encodeURIComponent","getMe","getUserPlaylists","getPlaylist","playlistId","getPlaylistTracks","createPlaylist","name","post","followPlaylist","put","unfollowPlaylist","del","changePlaylistDetails","uploadCustomPlaylistCoverImage","base64URI","addTracksToPlaylist","tracks","uris","removeTracksFromPlaylist","removeTracksFromPlaylistByPosition","positions","snapshotId","snapshot_id","replaceTracksInPlaylist","reorderTracksInPlaylist","rangeStart","insertBefore","console","log","range_start","insert_before","getAudioFeaturesForTrack","getAudioAnalysisForTrack","getAudioFeaturesForTracks","getRecommendations","_opts","optionsOfTypeArray","option","indexOf","toString","call","getAvailableGenreSeeds","getMySavedTracks","containsMySavedTracks","removeFromMySavedTracks","addToMySavedTracks","removeFromMySavedAlbums","addToMySavedAlbums","getMySavedAlbums","containsMySavedAlbums","getMyTopArtists","getMyTopTracks","getMyRecentlyPlayedTracks","addToQueue","getMyDevices","getMyCurrentPlayingTrack","getMyCurrentPlaybackState","transferMyPlayback","deviceIds","device_ids","play","_options","queryParams","device_id","postData","forEach","field","pause","skipToPrevious","skipToNext","seek","positionMs","params","position_ms","setRepeat","state","setShuffle","setVolume","volumePercent","volume_percent","followUsers","userIds","followArtists","unfollowUsers","unfollowArtists","isFollowingUsers","getFollowedArtists","areFollowingPlaylist","followerIds","isFollowingArtists","getNewReleases","getFeaturedPlaylists","getCategories","getCategory","categoryId","getPlaylistsForCategory","getShow","showId","getShows","showIds","containsMySavedShows","removeFromMySavedShows","addToMySavedShows","getMySavedShows","getShowEpisodes","searchShows","searchEpisodes","getEpisode","episodeId","getEpisodes","episodeIds","_addMethods","methods","superagent","TimeoutError","WebapiError","WebapiRegularError","WebapiAuthenticationError","WebapiPlayerError","_getParametersFromRequest","request","data","JSON","stringify","_makeRequest","req","bind","set","send","end","err","response","timeout","body","reason","statusCode","_toError","NamedError","constructor","message","error_description","SplitWidget","props","className","children","React","Component","checkLength","step","operands","operator","api","newAccessToken","a","meResponse","id","alert","fetchPlaylists","output","offset","limit","playlistsResponse","items","playlist","push","next","playlists","getPlaylists","playlistIdToTracks","Map","fetchTracks","tracksResponse","concat","getTracksForPlaylistId","has","savedTracks","getSavedTracks","fetchSavedTracks","pushToPlaylist","targetPlaylistId","trackUris","track","tracksPerRequest","slice","RecipeEditor","playlistsAlphabetical","editorType","recipe","errorText","initialRecipe","setState","onChange","event","handleNameChanged","target","SelectSearch","getPlaylistsAsSelectOptions","placeholder","handleTargetPlaylistChanged","disabled","steps","index","handleStepTypeModified","renderGuiStepOperators","onClick","handleAddNewStep","handleAppendStepModified","newName","recipeChanged","stepIndex","defaultValue","handleRenderTextChange","cols","rows","parsedRecipe","str","json","parse","parseRecipe","setEditorType","renderText","renderGui","onRecipeChanged","runRecipe","Api","includedTrackIds","includes","likedTrackIds","App","currentEditor","currentRecipeIndex","recipes","consoleLines","recipesServer","recipesDirty","localStorage","getItem","newRecipe","newEditor","handleRecipeChanged","window","confirm","splice","renderRecipesList","recipesServerChanged","pushToRecipesServer","loadFromRecipesServer","newServer","setItem","fetch","ok","mode","handleEditRecipe","handleRunRecipe","handleDeleteRecipe","Login","newClientId","scope","location","href","origin","htmlFor","handleClientIdChange","handleLogin","queryString","hash","replace","urlParams","URLSearchParams","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.a5633ca7.chunk.js","sourcesContent":["'use strict';\n\nvar Request = function(builder) {\n  if (!builder) {\n    throw new Error('No builder supplied to constructor');\n  }\n\n  this.host = builder.host;\n  this.port = builder.port;\n  this.scheme = builder.scheme;\n  this.queryParameters = builder.queryParameters;\n  this.bodyParameters = builder.bodyParameters;\n  this.headers = builder.headers;\n  this.path = builder.path;\n};\n\nRequest.prototype._getter = function(key) {\n  return function() {\n    return this[key];\n  };\n};\n\nRequest.prototype.getHost = Request.prototype._getter('host');\n\nRequest.prototype.getPort = Request.prototype._getter('port');\n\nRequest.prototype.getScheme = Request.prototype._getter('scheme');\n\nRequest.prototype.getPath = Request.prototype._getter('path');\n\nRequest.prototype.getQueryParameters = Request.prototype._getter(\n  'queryParameters'\n);\n\nRequest.prototype.getBodyParameters = Request.prototype._getter(\n  'bodyParameters'\n);\n\nRequest.prototype.getHeaders = Request.prototype._getter('headers');\n\nRequest.prototype.getURI = function() {\n  if (!this.scheme || !this.host || !this.port) {\n    throw new Error('Missing components necessary to construct URI');\n  }\n  var uri = this.scheme + '://' + this.host;\n  if (\n    (this.scheme === 'http' && this.port !== 80) ||\n    (this.scheme === 'https' && this.port !== 443)\n  ) {\n    uri += ':' + this.port;\n  }\n  if (this.path) {\n    uri += this.path;\n  }\n  return uri;\n};\n\nRequest.prototype.getURL = function() {\n  var uri = this.getURI();\n  if (this.getQueryParameters()) {\n    return uri + this.getQueryParameterString(this.getQueryParameters());\n  } else {\n    return uri;\n  }\n};\n\nRequest.prototype.getQueryParameterString = function() {\n  var queryParameters = this.getQueryParameters();\n  if (queryParameters) {\n    return (\n      '?' +\n      Object.keys(queryParameters)\n        .filter(function(key) {\n          return queryParameters[key] !== undefined;\n        })\n        .map(function(key) {\n          return key + '=' + queryParameters[key];\n        })\n        .join('&')\n    );\n  }\n};\n\nRequest.prototype.execute = function(method, callback) {\n  if (callback) {\n    method(this, callback);\n    return;\n  }\n  var _self = this;\n\n  return new Promise(function(resolve, reject) {\n    method(_self, function(error, result) {\n      if (error) {\n        reject(error);\n      } else {\n        resolve(result);\n      }\n    });\n  });\n};\n\nvar Builder = function() {};\n\nBuilder.prototype._setter = function(key) {\n  return function(value) {\n    this[key] = value;\n    return this;\n  };\n};\n\nBuilder.prototype.withHost = Builder.prototype._setter('host');\n\nBuilder.prototype.withPort = Builder.prototype._setter('port');\n\nBuilder.prototype.withScheme = Builder.prototype._setter('scheme');\n\nBuilder.prototype.withPath = Builder.prototype._setter('path');\n\nBuilder.prototype._assigner = function(key) {\n  return function() {\n    for (var i = 0; i < arguments.length; i++) {\n      this[key] = this._assign(this[key], arguments[i]);\n    }\n    \n    return this;\n  };\n};\n\nBuilder.prototype.withQueryParameters = Builder.prototype._assigner(\n  'queryParameters'\n);\n\nBuilder.prototype.withBodyParameters = Builder.prototype._assigner(\n  'bodyParameters'\n);\n\nBuilder.prototype.withHeaders = Builder.prototype._assigner('headers');\n\nBuilder.prototype.withAuth = function(accessToken) {\n  if (accessToken) {\n    this.withHeaders({ Authorization: 'Bearer ' + accessToken });\n  }\n  return this;\n};\n\nBuilder.prototype._assign = function(src, obj) {\n  if (obj && Array.isArray(obj)) {\n    return obj;\n  }\n  if (obj && typeof obj === 'string') {\n    return obj;\n  }\n  if (obj && Object.keys(obj).length > 0) {\n    return Object.assign(src || {}, obj);\n  }\n  return src;\n};\n\nBuilder.prototype.build = function() {\n  return new Request(this);\n};\n\nmodule.exports.builder = function() {\n  return new Builder();\n};\n","module.exports = require('./spotify-web-api');\n","'use strict';\n\nvar AuthenticationRequest = require('./authentication-request'),\n  WebApiRequest = require('./webapi-request'),\n  HttpManager = require('./http-manager');\n\nfunction SpotifyWebApi(credentials) {\n  this._credentials = credentials || {};\n}\n\nSpotifyWebApi.prototype = {\n  setCredentials: function(credentials) {\n    for (var key in credentials) {\n      if (credentials.hasOwnProperty(key)) {\n        this._credentials[key] = credentials[key];\n      }\n    }\n  },\n\n  getCredentials: function() {\n    return this._credentials;\n  },\n\n  resetCredentials: function() {\n    this._credentials = null;\n  },\n\n  setClientId: function(clientId) {\n    this._setCredential('clientId', clientId);\n  },\n\n  setClientSecret: function(clientSecret) {\n    this._setCredential('clientSecret', clientSecret);\n  },\n\n  setAccessToken: function(accessToken) {\n    this._setCredential('accessToken', accessToken);\n  },\n\n  setRefreshToken: function(refreshToken) {\n    this._setCredential('refreshToken', refreshToken);\n  },\n\n  setRedirectURI: function(redirectUri) {\n    this._setCredential('redirectUri', redirectUri);\n  },\n\n  getRedirectURI: function() {\n    return this._getCredential('redirectUri');\n  },\n\n  getClientId: function() {\n    return this._getCredential('clientId');\n  },\n\n  getClientSecret: function() {\n    return this._getCredential('clientSecret');\n  },\n\n  getAccessToken: function() {\n    return this._getCredential('accessToken');\n  },\n\n  getRefreshToken: function() {\n    return this._getCredential('refreshToken');\n  },\n\n  resetClientId: function() {\n    this._resetCredential('clientId');\n  },\n\n  resetClientSecret: function() {\n    this._resetCredential('clientSecret');\n  },\n\n  resetAccessToken: function() {\n    this._resetCredential('accessToken');\n  },\n\n  resetRefreshToken: function() {\n    this._resetCredential('refreshToken');\n  },\n\n  resetRedirectURI: function() {\n    this._resetCredential('redirectUri');\n  },\n\n  _setCredential: function(credentialKey, value) {\n    this._credentials = this._credentials || {};\n    this._credentials[credentialKey] = value;\n  },\n\n  _getCredential: function(credentialKey) {\n    if (!this._credentials) {\n      return;\n    } else {\n      return this._credentials[credentialKey];\n    }\n  },\n\n  _resetCredential: function(credentialKey) {\n    if (!this._credentials) {\n      return;\n    } else {\n      this._credentials[credentialKey] = null;\n    }\n  },\n\n  /**\n   * Look up a track.\n   * @param {string} trackId The track's ID.\n   * @param {Object} [options] The possible options, currently only market.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getTrack('3Qm86XLflmIXVm1wcwkgDK').then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing information\n   *          about the track. Not returned if a callback is given.\n   */\n  getTrack: function(trackId, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/tracks/' + trackId)\n      .withQueryParameters(options)\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Look up several tracks.\n   * @param {string[]} trackIds The IDs of the artists.\n   * @param {Object} [options] The possible options, currently only market.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getArtists(['0oSGxfWSnnOXhD2fKuz2Gy', '3dBVyJ7JuOMt4GE9607Qin']).then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing information\n   *          about the artists. Not returned if a callback is given.\n   */\n  getTracks: function(trackIds, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/tracks')\n      .withQueryParameters(\n        {\n          ids: trackIds.join(',')\n        },\n        options\n      )\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Look up an album.\n   * @param {string} albumId The album's ID.\n   * @param {Object} [options] The possible options, currently only market.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getAlbum('0sNOF9WDwhWunNAHPD3Baj').then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing information\n   *          about the album. Not returned if a callback is given.\n   */\n  getAlbum: function(albumId, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/albums/' + albumId)\n      .withQueryParameters(options)\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Look up several albums.\n   * @param {string[]} albumIds The IDs of the albums.\n   * @param {Object} [options] The possible options, currently only market.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getAlbums(['0oSGxfWSnnOXhD2fKuz2Gy', '3dBVyJ7JuOMt4GE9607Qin']).then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing information\n   *          about the albums. Not returned if a callback is given.\n   */\n  getAlbums: function(albumIds, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/albums')\n      .withQueryParameters(\n        {\n          ids: albumIds.join(',')\n        },\n        options\n      )\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Look up an artist.\n   * @param {string} artistId The artist's ID.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example api.getArtist('1u7kkVrr14iBvrpYnZILJR').then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing information\n   *          about the artist. Not returned if a callback is given.\n   */\n  getArtist: function(artistId, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/artists/' + artistId)\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Look up several artists.\n   * @param {string[]} artistIds The IDs of the artists.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getArtists(['0oSGxfWSnnOXhD2fKuz2Gy', '3dBVyJ7JuOMt4GE9607Qin']).then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing information\n   *          about the artists. Not returned if a callback is given.\n   */\n  getArtists: function(artistIds, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/artists')\n      .withQueryParameters({\n        ids: artistIds.join(',')\n      })\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Search for music entities of certain types.\n   * @param {string} query The search query.\n   * @param {string[]} types An array of item types to search across.\n   * Valid types are: 'album', 'artist', 'playlist', 'track', 'show', and 'episode'.\n   * @param {Object} [options] The possible options, e.g. limit, offset.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example search('Abba', ['track', 'playlist'], { limit : 5, offset : 1 }).then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing the\n   *          search results. The result is paginated. If the promise is rejected,\n   *          it contains an error object. Not returned if a callback is given.\n   */\n  search: function(query, types, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/search/')\n      .withQueryParameters(\n        {\n          type: types.join(','),\n          q: query\n        },\n        options\n      )\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Search for an album.\n   * @param {string} query The search query.\n   * @param {Object} [options] The possible options, e.g. limit, offset.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example searchAlbums('Space Oddity', { limit : 5, offset : 1 }).then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing the\n   *          search results. The result is paginated. If the promise is rejected,\n   *          it contains an error object. Not returned if a callback is given.\n   */\n  searchAlbums: function(query, options, callback) {\n    return this.search(query, ['album'], options, callback);\n  },\n\n  /**\n   * Search for an artist.\n   * @param {string} query The search query.\n   * @param {Object} [options] The possible options, e.g. limit, offset.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example searchArtists('David Bowie', { limit : 5, offset : 1 }).then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing the\n   *          search results. The result is paginated. If the promise is rejected,\n   *          it contains an error object. Not returned if a callback is given.\n   */\n  searchArtists: function(query, options, callback) {\n    return this.search(query, ['artist'], options, callback);\n  },\n\n  /**\n   * Search for a track.\n   * @param {string} query The search query.\n   * @param {Object} [options] The possible options, e.g. limit, offset.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example searchTracks('Mr. Brightside', { limit : 3, offset : 2 }).then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing the\n   *          search results. The result is paginated. If the promise is rejected,\n   *          it contains an error object. Not returned if a callback is given.\n   */\n  searchTracks: function(query, options, callback) {\n    return this.search(query, ['track'], options, callback);\n  },\n\n  /**\n   * Search for playlists.\n   * @param {string} query The search query.\n   * @param {Object} options The possible options.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example searchPlaylists('workout', { limit : 1, offset : 0 }).then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing the\n   *          search results. The result is paginated. If the promise is rejected,\n   *          it contains an error object. Not returned if a callback is given.\n   */\n  searchPlaylists: function(query, options, callback) {\n    return this.search(query, ['playlist'], options, callback);\n  },\n\n  /**\n   * Get an artist's albums.\n   * @param {string} artistId The artist's ID.\n   * @options {Object} [options] The possible options, e.g. limit, offset.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getArtistAlbums('0oSGxfWSnnOXhD2fKuz2Gy', { album_type : 'album', country : 'GB', limit : 2, offset : 5 }).then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing the albums\n   *          for the given artist. The result is paginated. If the promise is rejected,\n   *          it contains an error object. Not returned if a callback is given.\n   */\n  getArtistAlbums: function(artistId, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/artists/' + artistId + '/albums')\n      .withQueryParameters(options)\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Get the tracks of an album.\n   * @param albumId the album's ID.\n   * @options {Object} [options] The possible options, e.g. limit.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getAlbumTracks('41MnTivkwTO3UUJ8DrqEJJ', { limit : 5, offset : 1 }).then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing the\n   *                    tracks in the album. The result is paginated. If the promise is rejected.\n   *                    it contains an error object. Not returned if a callback is given.\n   */\n  getAlbumTracks: function(albumId, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/albums/' + albumId + '/tracks')\n      .withQueryParameters(options)\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Get an artist's top tracks.\n   * @param {string} artistId The artist's ID.\n   * @param {string} country The country/territory where the tracks are most popular. (format: ISO 3166-1 alpha-2)\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getArtistTopTracks('0oSGxfWSnnOXhD2fKuz2Gy', 'GB').then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing the\n   *          artist's top tracks in the given country. If the promise is rejected,\n   *          it contains an error object. Not returned if a callback is given.\n   */\n  getArtistTopTracks: function(artistId, country, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/artists/' + artistId + '/top-tracks')\n      .withQueryParameters({\n        country: country\n      })\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Get related artists.\n   * @param {string} artistId The artist's ID.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getArtistRelatedArtists('0oSGxfWSnnOXhD2fKuz2Gy').then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing the\n   *          related artists. If the promise is rejected, it contains an error object. Not returned if a callback is given.\n   */\n  getArtistRelatedArtists: function(artistId, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/artists/' + artistId + '/related-artists')\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Get information about a user.\n   * @param userId The user ID.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getUser('thelinmichael').then(...)\n   * @returns {Promise|undefined} A promise that if successful, resolves to an object\n   *          containing information about the user. If the promise is\n   *          rejected, it contains an error object. Not returned if a callback is given.\n   */\n  getUser: function(userId, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/users/' + encodeURIComponent(userId))\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Get information about the user that has signed in (the current user).\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getMe().then(...)\n   * @returns {Promise|undefined} A promise that if successful, resolves to an object\n   *          containing information about the user. The amount of information\n   *          depends on the permissions given by the user. If the promise is\n   *          rejected, it contains an error object. Not returned if a callback is given.\n   */\n  getMe: function(callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/me')\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Get a user's playlists.\n   * @param {string} userId An optional id of the user. If you know the Spotify URI it is easy\n   * to find the id (e.g. spotify:user:<here_is_the_id>). If not provided, the id of the user that granted\n   * the permissions will be used.\n   * @param {Object} [options] The options supplied to this request.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getUserPlaylists('thelinmichael').then(...)\n   * @returns {Promise|undefined} A promise that if successful, resolves to an object containing\n   *          a list of playlists. If rejected, it contains an error object. Not returned if a callback is given.\n   */\n  getUserPlaylists: function(userId, options, callback) {\n    var path;\n    if (typeof userId === 'string') {\n      path = '/v1/users/' + encodeURIComponent(userId) + '/playlists';\n    } else if (typeof userId === 'object') {\n      callback = options;\n      options = userId;\n      path = '/v1/me/playlists';\n    } /* undefined */ else {\n      path = '/v1/me/playlists';\n    }\n\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath(path)\n      .withQueryParameters(options)\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Get a playlist.\n   * @param {string} playlistId The playlist's ID.\n   * @param {Object} [options] The options supplied to this request.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getPlaylist('3EsfV6XzCHU8SPNdbnFogK').then(...)\n   * @returns {Promise|undefined} A promise that if successful, resolves to an object containing\n   *          the playlist. If rejected, it contains an error object. Not returned if a callback is given.\n   */\n  getPlaylist: function(playlistId, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/playlists/' + playlistId)\n      .withQueryParameters(options)\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Get tracks in a playlist.\n   * @param {string} playlistId The playlist's ID.\n   * @param {Object} [options] Optional options, such as fields.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getPlaylistTracks('3ktAYNcRHpazJ9qecm3ptn').then(...)\n   * @returns {Promise|undefined} A promise that if successful, resolves to an object that containing\n   * the tracks in the playlist. If rejected, it contains an error object. Not returned if a callback is given.\n   */\n  getPlaylistTracks: function(playlistId, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/playlists/' + playlistId + '/tracks')\n      .withQueryParameters(options)\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Create a playlist.\n   * @param {string} [name] The name of the playlist.\n   * @param {Object} [options] The possible options, being description, collaborative and public.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example createPlaylist('My playlist', {''description': 'My description', 'collaborative' : false, 'public': true}).then(...)\n   * @returns {Promise|undefined} A promise that if successful, resolves to an object containing information about the\n   *          created playlist. If rejected, it contains an error object. Not returned if a callback is given.\n   */\n  createPlaylist: function(name, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/me/playlists')\n      .withHeaders({ 'Content-Type': 'application/json' })\n      .withBodyParameters({\n        name : name,\n      }, options)\n      .build()\n      .execute(HttpManager.post, callback);\n  },\n\n  /**\n   * Follow a playlist.\n   * @param {string} playlistId The playlist's ID\n   * @param {Object} [options] The possible options, currently only public.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, simply resolves to an empty object. If rejected,\n   * it contains an error object. Not returned if a callback is given.\n   */\n  followPlaylist: function(playlistId, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/playlists/' + playlistId + '/followers')\n      .withHeaders({ 'Content-Type': 'application/json' })\n      .withBodyParameters(options)\n      .build()\n      .execute(HttpManager.put, callback);\n  },\n\n  /**\n   * Unfollow a playlist.\n   * @param {string} playlistId The playlist's ID\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, simply resolves to an empty object. If rejected,\n   * it contains an error object. Not returned if a callback is given.\n   */\n  unfollowPlaylist: function(playlistId, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/playlists/' + playlistId + '/followers')\n      .build()\n      .execute(HttpManager.del, callback);\n  },\n\n  /**\n   * Change playlist details.\n   * @param {string} playlistId The playlist's ID\n   * @param {Object} [options] The possible options, e.g. name, public.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example changePlaylistDetails('3EsfV6XzCHU8SPNdbnFogK', {name: 'New name', public: true}).then(...)\n   * @returns {Promise|undefined} A promise that if successful, simply resolves to an empty object. If rejected,\n   * it contains an error object. Not returned if a callback is given.\n   */\n  changePlaylistDetails: function(playlistId, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/playlists/' + playlistId)\n      .withHeaders({ 'Content-Type': 'application/json' })\n      .withBodyParameters(options)\n      .build()\n      .execute(HttpManager.put, callback);\n  },\n\n  /**\n   * Replace the image used to represent a specific playlist.\n   * @param {string} playlistId The playlist's ID\n   * @param {string} base64URI Base64 encoded JPEG image data, maximum payload size is 256 KB\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example uploadCustomPlaylistCoverImage('3EsfV6XzCHU8SPNdbnFogK', 'longbase64uri').then(...)\n   * @returns {Promise|undefined} A promise that if successful, simply resolves to an empty object. If rejected,\n   * it contains an error object. Not returned if a callback is given.\n   */\n  uploadCustomPlaylistCoverImage: function(playlistId, base64URI, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/playlists/' + playlistId + '/images')\n      .withHeaders({ 'Content-Type': 'image/jpeg' })\n      .withBodyParameters(base64URI)\n      .build()\n      .execute(HttpManager.put, callback);\n  },\n\n  /**\n   * Add tracks to a playlist.\n   * @param {string} playlistId The playlist's ID\n   * @param {string[]} tracks URIs of the tracks to add to the playlist.\n   * @param {Object} [options] Options, position being the only one.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example addTracksToPlaylist('3EsfV6XzCHU8SPNdbnFogK',\n              '[\"spotify:track:4iV5W9uYEdYUVa79Axb7Rh\", \"spotify:track:1301WleyT98MSxVHPZCA6M\"]').then(...)\n   * @returns {Promise|undefined} A promise that if successful returns an object containing a snapshot_id. If rejected,\n   * it contains an error object. Not returned if a callback is given.\n   */\n  addTracksToPlaylist: function(playlistId, tracks, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/playlists/' + playlistId + '/tracks')\n      .withHeaders({ 'Content-Type': 'application/json' })\n      .withQueryParameters(options)\n      .withBodyParameters({\n        uris: tracks\n      })\n      .build()\n      .execute(HttpManager.post, callback);\n  },\n\n  /**\n   * Remove tracks from a playlist.\n   * @param {string} playlistId The playlist's ID\n   * @param {Object[]} tracks An array of objects containing a property called uri with the track URI (String), and\n   * an optional property called positions (int[]), e.g. { uri : \"spotify:track:491rM2JN8KvmV6p0oDDuJT\", positions : [0, 15] }\n   * @param {Object} options Options, snapshot_id being the only one.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful returns an object containing a snapshot_id. If rejected,\n   * it contains an error object. Not returned if a callback is given.\n   */\n  removeTracksFromPlaylist: function(playlistId, tracks, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/playlists/' + playlistId + '/tracks')\n      .withHeaders({ 'Content-Type': 'application/json' })\n      .withBodyParameters(\n        {\n          tracks: tracks\n        }, \n        options\n      )\n      .build()\n      .execute(HttpManager.del, callback);\n  },\n\n  /**\n   * Remove tracks from a playlist by position instead of specifying the tracks' URIs.\n   * @param {string} playlistId The playlist's ID\n   * @param {int[]} positions The positions of the tracks in the playlist that should be removed\n   * @param {string} snapshot_id The snapshot ID, or version, of the playlist. Required\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful returns an object containing a snapshot_id. If rejected,\n   * it contains an error object. Not returned if a callback is given.\n   */\n  removeTracksFromPlaylistByPosition: function(\n    playlistId,\n    positions,\n    snapshotId,\n    callback\n  ) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/playlists/' + playlistId + '/tracks')\n      .withHeaders({ 'Content-Type': 'application/json' })\n      .withBodyParameters({\n        positions: positions,\n        snapshot_id: snapshotId\n      })\n      .build()\n      .execute(HttpManager.del, callback);\n  },\n\n  /**\n   * Replace tracks in a playlist.\n   * @param {string} playlistId The playlist's ID\n   * @param {Object[]} uris An array of track URIs (strings)\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful returns an empty object. If rejected,\n   * it contains an error object. Not returned if a callback is given.\n   */\n  replaceTracksInPlaylist: function(playlistId, uris, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/playlists/' + playlistId + '/tracks')\n      .withHeaders({ 'Content-Type': 'application/json' })\n      .withBodyParameters({\n        uris: uris\n      })\n      .build()\n      .execute(HttpManager.put, callback);\n  },\n\n  /**\n   * Reorder tracks in a playlist.\n   * @param {string} playlistId The playlist's ID\n   * @param {int} rangeStart The position of the first track to be reordered.\n   * @param {int} insertBefore The position where the tracks should be inserted.\n   * @param {Object} options Optional parameters, i.e. range_length and snapshot_id.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful returns an object containing a snapshot_id. If rejected,\n   * it contains an error object. Not returned if a callback is given.\n   */\n  reorderTracksInPlaylist: function(\n    playlistId,\n    rangeStart,\n    insertBefore,\n    options,\n    callback\n  ) {\n    let uris = undefined;\n    if (options && options.uris) {\n      uris = '';\n      for (let i = 0; i < options.uris.length; i++) {\n        if (i)\n          uris += ',';\n        uris += options.uris[i];\n      }\n\n      options.uris = undefined;\n    }\n    console.log('uris:', uris);\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/playlists/' + playlistId + '/tracks')\n      .withHeaders({ 'Content-Type': 'application/json' })\n      // For some reason, URIs only works as a query parameter, not as part of the json request body like the documentation says.\n      .withQueryParameters({uris})\n      .withBodyParameters(\n        {\n          range_start: rangeStart,\n          insert_before: insertBefore\n        },\n        options\n      )\n      .build()\n      .execute(HttpManager.put, callback);\n  },\n\n  /**\n   * Get audio features for a single track identified by its unique Spotify ID.\n   * @param {string} trackId The track ID\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getAudioFeaturesForTrack('38P3Q4QcdjQALGF2Z92BmR').then(...)\n   * @returns {Promise|undefined} A promise that if successful, resolves to an object\n   *          containing information about the audio features. If the promise is\n   *          rejected, it contains an error object. Not returned if a callback is given.\n   */\n  getAudioFeaturesForTrack: function(trackId, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/audio-features/' + trackId)\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Get audio analysis for a single track identified by its unique Spotify ID.\n   * @param {string} trackId The track ID\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getAudioAnalysisForTrack('38P3Q4QcdjQALGF2Z92BmR').then(...)\n   * @returns {Promise|undefined} A promise that if successful, resolves to an object\n   *          containing information about the audio analysis. If the promise is\n   *          rejected, it contains an error object. Not returned if a callback is given.\n   */\n  getAudioAnalysisForTrack: function(trackId, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/audio-analysis/' + trackId)\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Get audio features for multiple tracks identified by their unique Spotify ID.\n   * @param {string[]} trackIds The track IDs\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getAudioFeaturesForTracks(['38P3Q4QcdjQALGF2Z92BmR', '2HO2bnoMrpnZUbUqiilLHi']).then(...)\n   * @returns {Promise|undefined} A promise that if successful, resolves to an object\n   *          containing information about the audio features for the tracks. If the promise is\n   *          rejected, it contains an error object. Not returned if a callback is given.\n   */\n  getAudioFeaturesForTracks: function(trackIds, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/audio-features')\n      .withQueryParameters({\n        ids: trackIds.join(',')\n      })\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Create a playlist-style listening experience based on seed artists, tracks and genres.\n   * @param {Object} [options] The options supplied to this request.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getRecommendations({ min_energy: 0.4, seed_artists: ['6mfK6Q2tzLMEchAr0e9Uzu', '4DYFVNKZ1uixa6SQTvzQwJ'], min_popularity: 50 }).then(...)\n   * @returns {Promise|undefined} A promise that if successful, resolves to an object containing\n   *          a list of tracks and a list of seeds. If rejected, it contains an error object. Not returned if a callback is given.\n   */\n  getRecommendations: function(options, callback) {\n    var _opts = {};\n    var optionsOfTypeArray = ['seed_artists', 'seed_genres', 'seed_tracks'];\n    for (var option in options) {\n      if (options.hasOwnProperty(option)) {\n        if (\n          optionsOfTypeArray.indexOf(option) !== -1 &&\n          Object.prototype.toString.call(options[option]) === '[object Array]'\n        ) {\n          _opts[option] = options[option].join(',');\n        } else {\n          _opts[option] = options[option];\n        }\n      }\n    }\n\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/recommendations')\n      .withQueryParameters(_opts)\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Retrieve a list of available genres seed parameter values for recommendations.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getAvailableGenreSeeds().then(...)\n   * @returns {Promise|undefined} A promise that if successful, resolves to an object containing\n   *          a list of available genres to be used as seeds for recommendations.\n   *          If rejected, it contains an error object. Not returned if a callback is given.\n   */\n  getAvailableGenreSeeds: function(callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/recommendations/available-genre-seeds')\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Retrieve the tracks that are saved to the authenticated users Your Music library.\n   * @param {Object} [options] Options, being market, limit, and/or offset.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves to an object containing a paging object which in turn contains\n   *          playlist track objects. Not returned if a callback is given.\n   */\n  getMySavedTracks: function(options, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/me/tracks')\n      .withQueryParameters(options)\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Check if one or more tracks is already saved in the current Spotify user’s “Your Music” library.\n   * @param {string[]} trackIds The track IDs\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves into an array of booleans. The order\n   * of the returned array's elements correspond to the track ID in the request.\n   * The boolean value of true indicates that the track is part of the user's library, otherwise false.\n   * Not returned if a callback is given.\n   */\n  containsMySavedTracks: function(trackIds, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/me/tracks/contains')\n      .withQueryParameters({\n        ids: trackIds.join(',')\n      })\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Remove a track from the authenticated user's Your Music library.\n   * @param {string[]} trackIds The track IDs\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful returns null, otherwise an error.\n   * Not returned if a callback is given.\n   */\n  removeFromMySavedTracks: function(trackIds, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/me/tracks')\n      .withHeaders({ 'Content-Type': 'application/json' })\n      .withBodyParameters({ ids: trackIds })\n      .build()\n      .execute(HttpManager.del, callback);\n  },\n\n  /**\n   * Add a track from the authenticated user's Your Music library.\n   * @param {string[]} trackIds The track IDs\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful returns null, otherwise an error. Not returned if a callback is given.\n   */\n  addToMySavedTracks: function(trackIds, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/me/tracks')\n      .withHeaders({ 'Content-Type': 'application/json' })\n      .withBodyParameters({ ids: trackIds })\n      .build()\n      .execute(HttpManager.put, callback);\n  },\n\n  /**\n   * Remove an album from the authenticated user's Your Music library.\n   * @param {string[]} albumIds The album IDs\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful returns null, otherwise an error.\n   * Not returned if a callback is given.\n   */\n  removeFromMySavedAlbums: function(albumIds, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/me/albums')\n      .withHeaders({ 'Content-Type': 'application/json' })\n      .withBodyParameters(albumIds)\n      .build()\n      .execute(HttpManager.del, callback);\n  },\n\n  /**\n   * Add an album from the authenticated user's Your Music library.\n   * @param {string[]} albumIds The track IDs\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful returns null, otherwise an error. Not returned if a callback is given.\n   */\n  addToMySavedAlbums: function(albumIds, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/me/albums')\n      .withHeaders({ 'Content-Type': 'application/json' })\n      .withBodyParameters(albumIds)\n      .build()\n      .execute(HttpManager.put, callback);\n  },\n\n  /**\n   * Retrieve the albums that are saved to the authenticated users Your Music library.\n   * @param {Object} [options] Options, being market, limit, and/or offset.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves to an object containing a paging object which in turn contains\n   *          playlist album objects. Not returned if a callback is given.\n   */\n  getMySavedAlbums: function(options, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/me/albums')\n      .withQueryParameters(options)\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Check if one or more albums is already saved in the current Spotify user’s “Your Music” library.\n   * @param {string[]} albumIds The album IDs\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves into an array of booleans. The order\n   * of the returned array's elements correspond to the album ID in the request.\n   * The boolean value of true indicates that the album is part of the user's library, otherwise false.\n   * Not returned if a callback is given.\n   */\n  containsMySavedAlbums: function(albumIds, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/me/albums/contains')\n      .withQueryParameters({\n        ids: albumIds.join(',')\n      })\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Get the current user's top artists based on calculated affinity.\n   * @param {Object} [options] Options, being time_range, limit, offset.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves into a paging object of artists,\n   *          otherwise an error. Not returned if a callback is given.\n   */\n  getMyTopArtists: function(options, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/me/top/artists')\n      .withQueryParameters(options)\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Get the current user's top tracks based on calculated affinity.\n   * @param {Object} [options] Options, being time_range, limit, offset.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves into a paging object of tracks,\n   *          otherwise an error. Not returned if a callback is given.\n   */\n  getMyTopTracks: function(options, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/me/top/tracks')\n      .withQueryParameters(options)\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Get the Current User's Recently Played Tracks\n   * @param {Object} [options] Options, being type, after, limit, before.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves into a paging object of play history objects,\n   *          otherwise an error. Not returned if a callback is given. Note that the response will be empty\n   *          in case the user has enabled private session.\n   */\n  getMyRecentlyPlayedTracks: function(options, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/me/player/recently-played')\n      .withQueryParameters(options)\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Add track or episode to device queue\n   * @param {string} [uri] uri of the track or episode to add\n   * @param {Object} [options] Options, being device_id.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves into a paging object of tracks,\n   *          otherwise an error. Not returned if a callback is given.\n   */\n  addToQueue: function(uri, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/me/player/queue')\n      .withQueryParameters(\n        {\n          uri: uri\n        },\n        options\n      )\n      .build()\n      .execute(HttpManager.post, callback);\n  },\n\n\n  /** \n   * Get the Current User's Available Devices\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves into an array of device objects,\n   *          otherwise an error. Not returned if a callback is given.\n   */\n  getMyDevices: function(callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/me/player/devices')\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Get the Current User's Currently Playing Track.\n   * @param {Object} [options] Options, being market.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves into a paging object of tracks,\n   *          otherwise an error. Not returned if a callback is given.\n   */\n  getMyCurrentPlayingTrack: function(options, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/me/player/currently-playing')\n      .withQueryParameters(options)\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Get Information About The User's Current Playback State\n   * @param {Object} [options] Options, being market and additional_types.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves into a paging object of tracks,\n   *          otherwise an error. Not returned if a callback is given.\n   */\n  getMyCurrentPlaybackState: function(options, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/me/player')\n      .withQueryParameters(options)\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Transfer a User's Playback\n   * @param {string[]} [deviceIds] An _array_ containing a device ID on which playback should be started/transferred. \n   * (NOTE: The API is currently only supporting a single device ID.)\n   * @param {Object} [options] Options, the only one being 'play'.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves into an empty response,\n   *          otherwise an error. Not returned if a callback is given.\n   */\n  transferMyPlayback: function(deviceIds, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/me/player')\n      .withHeaders({ 'Content-Type': 'application/json' })\n      .withBodyParameters(\n        {\n          device_ids: deviceIds,\n        },\n        options\n      )\n      .build()\n      .execute(HttpManager.put, callback);\n  },\n\n  /**\n   * Starts o Resumes the Current User's Playback\n   * @param {Object} [options] Options, being device_id, context_uri, offset, uris, position_ms.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example play({context_uri: 'spotify:album:5ht7ItJgpBH7W6vJ5BqpPr'}).then(...)\n   * @returns {Promise|undefined} A promise that if successful, resolves into an empty response,\n   *          otherwise an error. Not returned if a callback is given.\n   */\n  play: function(options, callback) {\n    /*jshint camelcase: false */\n    var _options = options || {};\n    var queryParams = _options.device_id\n      ? { device_id: _options.device_id }\n      : null;\n    var postData = {};\n    ['context_uri', 'uris', 'offset', 'position_ms'].forEach(function(field) {\n      if (field in _options) {\n        postData[field] = _options[field];\n      }\n    });\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/me/player/play')\n      .withQueryParameters(queryParams)\n      .withHeaders({ 'Content-Type': 'application/json' })\n      .withBodyParameters(postData)\n      .build()\n      .execute(HttpManager.put, callback);\n  },\n\n  /**\n   * Pauses the Current User's Playback\n   * @param {Object} [options] Options, being device_id. If left empty will target the user's currently active device.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example pause().then(...)\n   * @returns {Promise|undefined} A promise that if successful, resolves into an empty response,\n   *          otherwise an error. Not returned if a callback is given.\n   */\n  pause: function(options, callback) {\n    return (\n      WebApiRequest.builder(this.getAccessToken())\n        .withPath('/v1/me/player/pause')\n        /*jshint camelcase: false */\n        .withQueryParameters(\n          options && options.device_id ? { device_id: options.device_id } : null\n        )\n        .withHeaders({ 'Content-Type': 'application/json' })\n        .build()\n        .execute(HttpManager.put, callback)\n    );\n  },\n\n  /**\n   * Skip the Current User's Playback To Previous Track\n   * @param {Object} [options] Options, being device_id. If left empty will target the user's currently active device.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example skipToPrevious().then(...)\n   * @returns {Promise|undefined} A promise that if successful, resolves into an empty response,\n   *          otherwise an error. Not returned if a callback is given.\n   */\n  skipToPrevious: function(options, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/me/player/previous')\n      .withQueryParameters(\n        options && options.device_id ? { device_id: options.device_id } : null\n      )\n      .build()\n      .execute(HttpManager.post, callback);\n  },\n\n  /**\n   * Skip the Current User's Playback To Next Track\n   * @param {Object} [options] Options, being device_id. If left empty will target the user's currently active device.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example skipToNext().then(...)\n   * @returns {Promise|undefined} A promise that if successful, resolves into an empty response,\n   *          otherwise an error. Not returned if a callback is given.\n   */\n  skipToNext: function(options, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/me/player/next')\n      .withQueryParameters(\n        options && options.device_id ? { device_id: options.device_id } : null\n      )\n      .build()\n      .execute(HttpManager.post, callback);\n  },\n\n  /**\n   * Seeks to the given position in the user’s currently playing track.\n   *\n   * @param {number} positionMs The position in milliseconds to seek to. Must be a positive number.\n   * @param {Object} options Options, being device_id. If left empty will target the user's currently active device.\n   * @param {function(Object,Object)} callback An optional callback that receives 2 parameters. The first\n   * one is the error object (null if no error), and the second is the value if the request succeeded.\n   * @return {Object} Null if a callback is provided, a `Promise` object otherwise\n   */\n  seek: function(positionMs, options, callback) {\n    var params = {\n      /* jshint camelcase: false */\n      position_ms: positionMs\n    };\n    if (options && 'device_id' in options) {\n      /* jshint camelcase: false */\n      params.device_id = options.device_id;\n    }\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/me/player/seek')\n      .withQueryParameters(params)\n      .build()\n      .execute(HttpManager.put, callback);\n  },\n\n  /**\n   * Set Repeat Mode On The Current User's Playback\n   * @param {string} [state] State (track, context, or off)\n   * @param {Object} [options] Options, being device_id. If left empty will target the user's currently active device.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example setRepeat('context', {}).then(...)\n   * @returns {Promise|undefined} A promise that if successful, resolves into an empty response,\n   *          otherwise an error. Not returned if a callback is given.\n   */\n  setRepeat: function(state, options, callback) {\n    var params = {\n      state: state\n    };\n    if (options && 'device_id' in options) {\n      /* jshint camelcase: false */\n      params.device_id = options.device_id;\n    }\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/me/player/repeat')\n      .withQueryParameters(params)\n      .build()\n      .execute(HttpManager.put, callback);\n  },\n\n  /**\n   * Set Shuffle Mode On The Current User's Playback\n   * @param {boolean} [state] State \n   * @param {Object} [options] Options, being device_id. If left empty will target the user's currently active device.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example setShuffle({state: 'false'}).then(...)\n   * @returns {Promise|undefined} A promise that if successful, resolves into an empty response,\n   *          otherwise an error. Not returned if a callback is given.\n   */\n  setShuffle: function(state, options, callback) {\n    var params = {\n      state: state\n    };\n    if (options && 'device_id' in options) {\n      /* jshint camelcase: false */\n      params.device_id = options.device_id;\n    }\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/me/player/shuffle')\n      .withQueryParameters(params)\n      .build()\n      .execute(HttpManager.put, callback);\n  },\n\n  /**\n   * Set the volume for the user’s current playback device.\n   * @param {number} volumePercent The volume to set. Must be a value from 0 to 100.\n   * @param {Object} options Options, being device_id. If left empty will target the user's currently active device.\n   * @param {function(Object,Object)} callback An optional callback that receives 2 parameters. The first\n   * one is the error object (null if no error), and the second is the value if the request succeeded.\n   * @return {Object} Null if a callback is provided, a `Promise` object otherwise\n   */\n  setVolume: function(volumePercent, options, callback) {\n    var params = {\n      /* jshint camelcase: false */\n      volume_percent: volumePercent\n    };\n    if (options && 'device_id' in options) {\n      /* jshint camelcase: false */\n      params.device_id = options.device_id;\n    }\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/me/player/volume')\n      .withQueryParameters(params)\n      .build()\n      .execute(HttpManager.put, callback);\n  },\n\n  /**\n   * Add the current user as a follower of one or more other Spotify users.\n   * @param {string[]} userIds The IDs of the users to be followed.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example followUsers(['thelinmichael', 'wizzler']).then(...)\n   * @returns {Promise|undefined} A promise that if successful, simply resolves to an empty object. If rejected,\n   *          it contains an error object. Not returned if a callback is given.\n   */\n  followUsers: function(userIds, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/me/following')\n      .withQueryParameters({\n        ids: userIds.join(','),\n        type: 'user'\n      })\n      .build()\n      .execute(HttpManager.put, callback);\n  },\n\n  /**\n   * Add the current user as a follower of one or more artists.\n   * @param {string[]} artistIds The IDs of the artists to be followed.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example followArtists(['0LcJLqbBmaGUft1e9Mm8HV', '3gqv1kgivAc92KnUm4elKv']).then(...)\n   * @returns {Promise|undefined} A promise that if successful, simply resolves to an empty object. If rejected,\n   *          it contains an error object. Not returned if a callback is given.\n   */\n  followArtists: function(artistIds, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/me/following')\n      .withQueryParameters({\n        ids: artistIds.join(','),\n        type: 'artist'\n      })\n      .build()\n      .execute(HttpManager.put, callback);\n  },\n\n  /**\n   * Remove the current user as a follower of one or more other Spotify users.\n   * @param {string[]} userIds The IDs of the users to be unfollowed.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example unfollowUsers(['thelinmichael', 'wizzler']).then(...)\n   * @returns {Promise|undefined} A promise that if successful, simply resolves to an empty object. If rejected,\n   *          it contains an error object. Not returned if a callback is given.\n   */\n  unfollowUsers: function(userIds, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/me/following')\n      .withQueryParameters({\n        ids: userIds.join(','),\n        type: 'user'\n      })\n      .build()\n      .execute(HttpManager.del, callback);\n  },\n\n  /**\n   * Remove the current user as a follower of one or more artists.\n   * @param {string[]} artistIds The IDs of the artists to be unfollowed.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example unfollowArtists(['0LcJLqbBmaGUft1e9Mm8HV', '3gqv1kgivAc92KnUm4elKv']).then(...)\n   * @returns {Promise|undefined} A promise that if successful, simply resolves to an empty object. If rejected,\n   *          it contains an error object. Not returned if a callback is given.\n   */\n  unfollowArtists: function(artistIds, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/me/following')\n      .withQueryParameters({\n        ids: artistIds.join(','),\n        type: 'artist'\n      })\n      .build()\n      .execute(HttpManager.del, callback);\n  },\n\n  /**\n   * Check to see if the current user is following one or more other Spotify users.\n   * @param {string[]} userIds The IDs of the users to check if are followed by the current user.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example isFollowingUsers(['thelinmichael', 'wizzler']).then(...)\n   * @returns {Promise|undefined} A promise that if successful, resolves into an array of booleans. The order\n   *          of the returned array's elements correspond to the users IDs in the request.\n   *          The boolean value of true indicates that the user is following that user, otherwise is not.\n   *          Not returned if a callback is given.\n   */\n  isFollowingUsers: function(userIds, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/me/following/contains')\n      .withQueryParameters({\n        ids: userIds.join(','),\n        type: 'user'\n      })\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Get the current user's followed artists.\n   * @param {Object} [options] Options, being after and limit.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves to an object containing a paging object which contains\n   * album objects. Not returned if a callback is given.\n   */\n  getFollowedArtists: function(options, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/me/following')\n      .withQueryParameters(\n        {\n          type: 'artist'\n        },\n        options\n      )\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Check if users are following a playlist.\n   * @param {string} userId The playlist's owner's user ID\n   * @param {string} playlistId The playlist's ID\n   * @param {String[]} User IDs of the following users\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful returns an array of booleans. If rejected,\n   * it contains an error object. Not returned if a callback is given.\n   */\n  areFollowingPlaylist: function(userId, playlistId, followerIds, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath(\n        '/v1/users/' +\n          encodeURIComponent(userId) +\n          '/playlists/' +\n          playlistId +\n          '/followers/contains'\n      )\n      .withQueryParameters({\n        ids: followerIds.join(',')\n      })\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Check to see if the current user is following one or more artists.\n   * @param {string[]} artistIds The IDs of the artists to check if are followed by the current user.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example isFollowingArtists(['0LcJLqbBmaGUft1e9Mm8HV', '3gqv1kgivAc92KnUm4elKv']).then(...)\n   * @returns {Promise|undefined} A promise that if successful, resolves into an array of booleans. The order\n   *          of the returned array's elements correspond to the artists IDs in the request.\n   *          The boolean value of true indicates that the user is following that artist, otherwise is not.\n   *          Not returned if a callback is given.\n   */\n  isFollowingArtists: function(artistIds, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/me/following/contains')\n      .withQueryParameters({\n        ids: artistIds.join(','),\n        type: 'artist'\n      })\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Retrieve new releases\n   * @param {Object} [options] Options, being country, limit and/or offset.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves to an object containing a paging object which contains\n   * album objects. Not returned if a callback is given.\n   */\n  getNewReleases: function(options, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/browse/new-releases')\n      .withQueryParameters(options)\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Retrieve featured playlists\n   * @param {Object} [options] Options, being country, locale, timestamp, limit, offset.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves to an object containing a paging object which contains\n   * featured playlists. Not returned if a callback is given.\n   */\n  getFeaturedPlaylists: function(options, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/browse/featured-playlists')\n      .withQueryParameters(options)\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Retrieve a list of categories used to tag items in Spotify (e.g. in the 'Browse' tab)\n   * @param {Object} [options] Options, being country, locale, limit, offset.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves to an object containing a paging object of categories.\n   * Not returned if a callback is given.\n   */\n  getCategories: function(options, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/browse/categories')\n      .withQueryParameters(options)\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Retrieve a category.\n   * @param {string} categoryId The id of the category to retrieve.\n   * @param {Object} [options] Options, being country, locale.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves to an object containing a category object.\n   * Not returned if a callback is given.\n   */\n  getCategory: function(categoryId, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/browse/categories/' + categoryId)\n      .withQueryParameters(options)\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Retrieve playlists for a category.\n   * @param {string} categoryId The id of the category to retrieve playlists for.\n   * @param {Object} [options] Options, being country, limit, offset.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves to a paging object containing simple playlists.\n   * Not returned if a callback is given.\n   */\n  getPlaylistsForCategory: function(categoryId, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/browse/categories/' + categoryId + '/playlists')\n      .withQueryParameters(options)\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Get a show.\n   * @param {string} showId The show's ID.\n   * @param {Object} [options] The possible options, currently only market.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getShow('3Qm86XLflmIXVm1wcwkgDK').then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing information\n   *          about the show. Not returned if a callback is given.\n   */\n  getShow: function(showId, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n    .withPath('/v1/shows/' + showId)\n    .withQueryParameters(options)\n    .build()\n    .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Look up several shows.\n   * @param {string[]} showIds The IDs of the shows.\n   * @param {Object} [options] The possible options, currently only market.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getShows(['0oSGxfWSnnOXhD2fKuz2Gy', '3dBVyJ7JuOMt4GE9607Qin']).then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing information\n   *          about the shows. Not returned if a callback is given.\n   */\n  getShows: function(showIds, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/shows')\n      .withQueryParameters(\n        {\n          ids: showIds.join(',')\n        },\n        options\n      )\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Check if one or more shows is already saved in the current Spotify user’s “Your Music” library.\n   * @param {string[]} showIds The show IDs\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves into an array of booleans. The order\n   * of the returned array's elements correspond to the show ID in the request.\n   * The boolean value of true indicates that the show is part of the user's library, otherwise false.\n   * Not returned if a callback is given.\n   */\n  containsMySavedShows: function(showIds, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/me/shows/contains')\n      .withQueryParameters({\n        ids: showIds.join(',')\n      })\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Remove an show from the authenticated user's Your Music library.\n   * @param {string[]} showIds The show IDs\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful returns null, otherwise an error.\n   * Not returned if a callback is given.\n   */\n  removeFromMySavedShows: function(showIds, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/me/shows')\n      .withHeaders({ 'Content-Type': 'application/json' })\n      .withBodyParameters(showIds)\n      .build()\n      .execute(HttpManager.del, callback);\n  },\n\n  /**\n   * Add a show from the authenticated user's Your Music library.\n   * @param {string[]} showIds The show IDs\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful returns null, otherwise an error. Not returned if a callback is given.\n   */\n  addToMySavedShows: function(showIds, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/me/shows')\n      .withHeaders({ 'Content-Type': 'application/json' })\n      .withBodyParameters(showIds)\n      .build()\n      .execute(HttpManager.put, callback);\n  },\n\n  /**\n   * Retrieve the shows that are saved to the authenticated users Your Music library.\n   * @param {Object} [options] Options, being market, limit, and/or offset.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @returns {Promise|undefined} A promise that if successful, resolves to an object containing a paging object which in turn contains\n   *          playlist show objects. Not returned if a callback is given.\n   */\n  getMySavedShows: function(options, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/me/shows')\n      .withQueryParameters(options)\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Get the episodes of an show.\n   * @param showId the show's ID.\n   * @options {Object} [options] The possible options, being limit, offset, and market.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getShowEpisodes('41MnTivkwTO3UUJ8DrqEJJ', { limit : 5, offset : 1 }).then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing the\n   *                    episodes in the album. The result is paginated. If the promise is rejected.\n   *                    it contains an error object. Not returned if a callback is given.\n   */\n  getShowEpisodes: function(showId, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/shows/' + showId + '/episodes')\n      .withQueryParameters(options)\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Search for a show.\n   * @param {string} query The search query.\n   * @param {Object} [options] The possible options, e.g. limit, offset.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example searchShows('Space Oddity', { limit : 5, offset : 1 }).then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing the\n   *          search results. The result is paginated. If the promise is rejected,\n   *          it contains an error object. Not returned if a callback is given.\n   */\n  searchShows: function(query, options, callback) {\n    return this.search(query, ['show'], options, callback);\n  },\n\n  /**\n   * Search for an episode.\n   * @param {string} query The search query.\n   * @param {Object} [options] The possible options, e.g. limit, offset.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example searchEpisodes('Space Oddity', { limit : 5, offset : 1 }).then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing the\n   *          search results. The result is paginated. If the promise is rejected,\n   *          it contains an error object. Not returned if a callback is given.\n   */\n  searchEpisodes: function(query, options, callback) {\n    return this.search(query, ['episode'], options, callback);\n  },\n\n /**\n   * Look up an episode.\n   * @param {string} episodeId The episode's ID.\n   * @param {Object} [options] The possible options, currently only market.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getEpisode('3Qm86XLflmIXVm1wcwkgDK').then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing information\n   *          about the episode. Not returned if a callback is given.\n   */\n  getEpisode: function(episodeId, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/episodes/' + episodeId)\n      .withQueryParameters(options)\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n\n  /**\n   * Look up several episodes.\n   * @param {string[]} episodeIds The IDs of the episodes.\n   * @param {Object} [options] The possible options, currently only market.\n   * @param {requestCallback} [callback] Optional callback method to be called instead of the promise.\n   * @example getEpisodes(['0oSGxfWSnnOXhD2fKuz2Gy', '3dBVyJ7JuOMt4GE9607Qin']).then(...)\n   * @returns {Promise|undefined} A promise that if successful, returns an object containing information\n   *          about the episodes. Not returned if a callback is given.\n   */\n  getEpisodes: function(episodeIds, options, callback) {\n    return WebApiRequest.builder(this.getAccessToken())\n      .withPath('/v1/episodes')\n      .withQueryParameters(\n        {\n          ids: episodeIds.join(',')\n        },\n        options\n      )\n      .build()\n      .execute(HttpManager.get, callback);\n  },\n};\n\nSpotifyWebApi._addMethods = function(methods) {\n  for (var i in methods) {\n    if (methods.hasOwnProperty(i)) {\n      this.prototype[i] = methods[i];\n    }\n  }\n};\n\nmodule.exports = SpotifyWebApi;\n","'use strict';\n\nvar Request = require('./base-request');\n\nvar DEFAULT_HOST = 'accounts.spotify.com',\n  DEFAULT_PORT = 443,\n  DEFAULT_SCHEME = 'https';\n\nmodule.exports.builder = function() {\n  return Request.builder()\n    .withHost(DEFAULT_HOST)\n    .withPort(DEFAULT_PORT)\n    .withScheme(DEFAULT_SCHEME);\n};\n","'use strict';\n\nvar Request = require('./base-request');\n\nvar DEFAULT_HOST = 'api.spotify.com',\n  DEFAULT_PORT = 443,\n  DEFAULT_SCHEME = 'https';\n\nmodule.exports.builder = function(accessToken) {\n  return Request.builder()\n    .withHost(DEFAULT_HOST)\n    .withPort(DEFAULT_PORT)\n    .withScheme(DEFAULT_SCHEME)\n    .withAuth(accessToken);\n};\n","'use strict';\n\nvar superagent = require('superagent'),\n  { TimeoutError, \n    WebapiError, \n    WebapiRegularError, \n    WebapiAuthenticationError,\n    WebapiPlayerError \n  } =  require('./response-error');\n\nvar HttpManager = {};\n\n/* Create superagent options from the base request */\nvar _getParametersFromRequest = function(request) {\n  var options = {};\n\n  if (request.getQueryParameters()) {\n    options.query = request.getQueryParameters();\n  }\n\n  if (request.getHeaders() && request.getHeaders()['Content-Type'] === 'application/json') {\n    options.data = JSON.stringify(request.getBodyParameters());\n  } else if (request.getBodyParameters()) {\n    options.data = request.getBodyParameters();\n  }\n\n  if (request.getHeaders()) {\n    options.headers = request.getHeaders();\n  }\n  return options;\n};\n\nvar _toError = function(response) {\n  if (typeof response.body === 'object' && response.body.error && typeof response.body.error === 'object' && response.body.error.reason) {\n    return new WebapiPlayerError(response.body, response.headers, response.statusCode);\n  }\n\n  if (typeof response.body === 'object' && response.body.error && typeof response.body.error === 'object') {\n    return new WebapiRegularError(response.body, response.headers, response.statusCode);\n  }\n\n  if (typeof response.body === 'object' && response.body.error && typeof response.body.error === 'string') {\n    return new WebapiAuthenticationError(response.body, response.headers, response.statusCode);\n  }\n  \n  /* Other type of error, or unhandled Web API error format */\n  return new WebapiError(response.body, response.headers, response.statusCode, response.body);\n};\n\n/* Make the request to the Web API */\nHttpManager._makeRequest = function(method, options, uri, callback) {\n  var req = method.bind(superagent)(uri);\n\n  if (options.query) {\n    req.query(options.query);\n  }\n\n  if (options.headers) {\n    req.set(options.headers);\n  }\n\n  if (options.data) {\n    req.send(options.data);\n  }\n\n  req.end(function(err, response) {\n    if (err) {\n      if (err.timeout) {\n        return callback(new TimeoutError());\n      } else if (err.response) {\n        return callback(_toError(err.response));\n      } else {\n        return callback(err);\n      }\n    }\n\n    return callback(null, {\n      body: response.body,\n      headers: response.headers,\n      statusCode: response.statusCode\n    });\n  });\n};\n\n/**\n * Make a HTTP GET request.\n * @param {BaseRequest} The request.\n * @param {Function} The callback function.\n */\nHttpManager.get = function(request, callback) {\n  var options = _getParametersFromRequest(request);\n  var method = superagent.get;\n\n  HttpManager._makeRequest(method, options, request.getURI(), callback);\n};\n\n/**\n * Make a HTTP POST request.\n * @param {BaseRequest} The request.\n * @param {Function} The callback function.\n */\nHttpManager.post = function(request, callback) {\n  var options = _getParametersFromRequest(request);\n  var method = superagent.post;\n\n  HttpManager._makeRequest(method, options, request.getURI(), callback);\n};\n\n/**\n * Make a HTTP DELETE request.\n * @param {BaseRequest} The request.\n * @param {Function} The callback function.\n */\nHttpManager.del = function(request, callback) {\n  var options = _getParametersFromRequest(request);\n  var method = superagent.del;\n\n  HttpManager._makeRequest(method, options, request.getURI(), callback);\n};\n\n/**\n * Make a HTTP PUT request.\n * @param {BaseRequest} The request.\n * @param {Function} The callback function.\n */\nHttpManager.put = function(request, callback) {\n  var options = _getParametersFromRequest(request);\n  var method = superagent.put;\n\n  HttpManager._makeRequest(method, options, request.getURI(), callback);\n};\n\nmodule.exports = HttpManager;","/* Timeout */\nclass NamedError extends Error {\n  get name() {\n    return this.constructor.name;\n  }  \n}\n\nclass TimeoutError extends NamedError {\n  constructor() {\n    const message = 'A timeout occurred while communicating with Spotify\\'s Web API.';\n    super(message);\n  }\n\n}\n\n/* Web API Parent and fallback error */\nclass WebapiError extends NamedError {\n  constructor(body, headers, statusCode, message) {\n    super(message);\n    this.body = body;\n    this.headers = headers;\n    this.statusCode = statusCode;\n  }\n\n}\n\n/** \n * Regular Error\n * { status : <integer>, message : <string> }\n */\nclass WebapiRegularError extends WebapiError {\n  constructor(body, headers, statusCode) {\n    const message = 'An error occurred while communicating with Spotify\\'s Web API.\\n' +\n    'Details: ' + body.error.message + '.';\n\n    super(body, headers, statusCode, message);\n  }\n}\n\n/**\n * Authentication Error \n * { error : <string>, error_description : <string> }\n */\nclass WebapiAuthenticationError extends WebapiError {\n  constructor(body, headers, statusCode) {\n    const message = 'An authentication error occurred while communicating with Spotify\\'s Web API.\\n' +\n    'Details: ' + body.error + (body.error_description ? ' ' + body.error_description + '.' : '.');\n\n    super(body, headers, statusCode, message);\n  }\n}\n\n/**\n * Player Error \n * { status : <integer>, message : <string>, reason : <string> }\n */\nclass WebapiPlayerError extends WebapiError {\n  constructor(body, headers, statusCode) {\n    const message = 'An error occurred while communicating with Spotify\\'s Web API.\\n' +\n    'Details: ' + body.error.message + (body.error.reason ? ' ' + body.error.reason + '.' : '.');\n\n    super(body, headers, statusCode, message);\n  }\n}\n\nmodule.exports = { WebapiError, TimeoutError, WebapiRegularError, WebapiAuthenticationError, WebapiPlayerError };","import React from 'react';\r\nimport './SplitWidget.css';\r\n\r\nclass SplitWidget extends React.Component {\r\n  constructor(props: {}) {\r\n    super(props);\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <div className=\"split-widget\">\r\n        {this.props.children}\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default SplitWidget;\r\n","//import { JsonDecoder } from 'ts.data.json';\r\n\r\nexport interface Recipe {\r\n  targetPlaylistId: string;\r\n  steps: Array<Step>;\r\n  name: string;\r\n}\r\nexport type StepOperator = 'appendPlaylistById'|'filterByPlaylistId'|'filterBySavedTracks';\r\nexport interface Step {\r\n  operator: StepOperator;\r\n  operands: Array<string>;\r\n}\r\nexport function getStepOperators(): Array<StepOperator> {\r\n  return ['appendPlaylistById','filterByPlaylistId','filterBySavedTracks'];\r\n}\r\nexport interface AppendPlaylistStep extends Step {\r\n  operator: 'appendPlaylistById';\r\n  operands: [playlistId: string];\r\n}\r\nexport interface FilterByPlaylistStep extends Step {\r\n  operator: 'filterByPlaylistId';\r\n  operands: [playlistId: string];\r\n}\r\nexport interface FilterBySavedTracksStep extends Step {\r\n  operator: 'filterBySavedTracks';\r\n  operands: [];\r\n}\r\n\r\n/*const stepDecoder = JsonDecoder.object<Step>(\r\n  {\r\n    operands: \r\n  },\r\n  'Step'\r\n);\r\n\r\nconst recipeDecoder = JsonDecoder.object<Recipe>(\r\n  {\r\n    name: JsonDecoder.string,\r\n    targetPlaylistId: JsonDecoder.string,\r\n    steps: JsonDecoder.array<Step>(\r\n      {\r\n        operator: JsonDecoder.string\r\n      },\r\n      'Step'\r\n    )\r\n  },\r\n  'Recipe'\r\n);*/\r\n\r\nexport function parseRecipe(str: string): Recipe|string {\r\n  // TODO use a library for this...?\r\n  try {\r\n    const json: Recipe = JSON.parse(str);\r\n    if (!json.targetPlaylistId) {\r\n      return 'no targetPlaylistId';\r\n    }\r\n    if (!json.steps) {\r\n      return 'no steps;'\r\n    }\r\n    for (const step of json.steps) {\r\n      if (!(step.operands instanceof Array)) {\r\n        return 'no operands array';\r\n      }\r\n      let error;\r\n      switch (step.operator) {\r\n        case 'appendPlaylistById':\r\n          error = checkLength(step, 1);\r\n          if (error) return error;\r\n          break;\r\n\r\n        case 'filterByPlaylistId':\r\n          error = checkLength(step, 1);\r\n          if (error) return error;\r\n          break;\r\n\r\n        case 'filterBySavedTracks':\r\n          error = checkLength(step, 0);\r\n          if (error) return error;\r\n          break;\r\n\r\n        default:\r\n          return 'unrecognized operator: ' + step.operator;\r\n      }\r\n    }\r\n    if (!json.name) {\r\n      return 'no name';\r\n    }\r\n    return json;\r\n  } catch (error) {\r\n    return 'failed to parse recipe: ' + error;\r\n  }\r\n}\r\nfunction checkLength(step: Step, length: number): string|null {\r\n  if (step.operands.length !== length) {\r\n    return `${step.operator} should have operands of length ${length}, but instead got ${step.operands.length}`;\r\n  }\r\n  return null;\r\n}","import SpotifyWebApi from 'spotify-web-api-node';\r\n\r\nlet accessToken = '';\r\nlet userId = '';\r\nconst api = new SpotifyWebApi();\r\nexport async function setAccessToken(newAccessToken: string): Promise<boolean> {\r\n  accessToken = newAccessToken;\r\n  api.setAccessToken(accessToken);\r\n  try {\r\n    const meResponse = await api.getMe();\r\n    userId = meResponse.body.id;\r\n  } catch (error) {\r\n    // TODO snoop error message for expiry, not sure what else this case could cover\r\n    alert('access_token expired, log in again to get a new one.');\r\n    return false;\r\n  }\r\n  return true;\r\n}\r\nexport function getAccessToken(): string {\r\n  return accessToken;\r\n}\r\n\r\nexport type PlaylistMap = Map<string, SpotifyApi.PlaylistObjectSimplified>;\r\nexport type PlaylistList = Array<SpotifyApi.PlaylistObjectSimplified>;\r\nasync function fetchPlaylists(): Promise<PlaylistList> {\r\n  // TODO figure out how to use console output here\r\n  const output = [];\r\n  let playlistsResponse;\r\n  let offset = 0;\r\n  do {\r\n    // TODO add floating centered modal loading widget here?\r\n    playlistsResponse = await api.getUserPlaylists(userId, {limit: 50, offset});\r\n    for (const playlist of playlistsResponse.body.items) {\r\n      output.push(playlist);\r\n    }\r\n    offset += playlistsResponse.body.items.length;\r\n  } while (playlistsResponse.body.next);\r\n  return output;\r\n}\r\nlet playlists: PlaylistList|null = null;\r\nexport async function getPlaylists(): Promise<PlaylistList> {\r\n  if (!playlists)\r\n    playlists = await fetchPlaylists();\r\n  return playlists;\r\n}\r\nlet idToPlaylist: PlaylistMap|null = null;\r\nexport async function getPlaylistsById(): Promise<PlaylistMap> {\r\n  if (!idToPlaylist) {\r\n    const playlists = await getPlaylists();\r\n    idToPlaylist = new Map();\r\n    for (const playlist of playlists) {\r\n      idToPlaylist.set(playlist.id, playlist);\r\n    }\r\n  }\r\n  return idToPlaylist;\r\n}\r\n\r\nconst playlistIdToTracks = new Map();\r\nasync function fetchTracks(playlistId: string): Promise<Array<SpotifyApi.PlaylistTrackObject>> {\r\n  let tracks: Array<SpotifyApi.PlaylistTrackObject> = [];\r\n  let tracksResponse;\r\n  let offset = 0;\r\n  do {\r\n    tracksResponse = await api.getPlaylistTracks(playlistId, {limit: 50, offset});\r\n    tracks = tracks.concat(tracksResponse.body.items);\r\n    offset += tracksResponse.body.items.length;\r\n  } while (tracksResponse.body.next);\r\n  return tracks;\r\n}\r\nexport async function getTracksForPlaylistId(playlistId: string): Promise<Array<SpotifyApi.PlaylistTrackObject>> {\r\n  if (!playlistIdToTracks.has(playlistId)) {\r\n    playlistIdToTracks.set(playlistId, await fetchTracks(playlistId));\r\n  }\r\n  return playlistIdToTracks.get(playlistId);\r\n}\r\n\r\nlet savedTracks: Array<SpotifyApi.SavedTrackObject>|null = null;\r\nexport async function getSavedTracks(): Promise<Array<SpotifyApi.SavedTrackObject>> {\r\n  if (!savedTracks) {\r\n    savedTracks = await fetchSavedTracks();\r\n  }\r\n  return savedTracks;\r\n}\r\nasync function fetchSavedTracks(): Promise<Array<SpotifyApi.SavedTrackObject>> {\r\n  let tracks: Array<SpotifyApi.SavedTrackObject> = [];\r\n  let offset = 0;\r\n  let tracksResponse;\r\n  do {\r\n    tracksResponse = await api.getMySavedTracks({limit: 50, offset});\r\n    tracks = tracks.concat(tracksResponse.body.items);\r\n    offset += tracksResponse.body.items.length;\r\n  } while (tracksResponse.body.next);\r\n  return tracks;\r\n}\r\n\r\nexport function invalidatePlaylistById(playlistId: string) {\r\n  if (idToPlaylist)\r\n    idToPlaylist.delete(playlistId);\r\n  playlistIdToTracks.delete(playlistId);\r\n}\r\n\r\nexport async function pushToPlaylist(targetPlaylistId: string, tracks: Array<SpotifyApi.TrackObjectFull>) {\r\n  const trackUris = tracks.map(track => track.uri);\r\n  const tracksPerRequest = 50;\r\n  for (let i = 0; i < tracks.length; i += tracksPerRequest) {\r\n    const response = await api.reorderTracksInPlaylist(\r\n      targetPlaylistId,\r\n      /*rangeStart=*/0,\r\n      /*insertBefore=*/i, // TODO idk if this is correct\r\n      {\r\n        /* @ts-ignore */\r\n        uris: trackUris.slice(i, i + tracksPerRequest)\r\n      });\r\n  }\r\n}","import React from 'react';\r\nimport { Recipe, parseRecipe, getStepOperators, StepOperator, Step } from './Recipe';\r\nimport SelectSearch, { SelectedOptionValue } from 'react-select-search';\r\nimport * as api from './Api';\r\nimport { formatWithOptions } from 'node:util';\r\nimport ConsoleOutput from './ConsoleOutput';\r\n\r\ninterface Props {\r\n  initialRecipe: Recipe;\r\n  onRecipeChanged: (recipe: Recipe) => void;\r\n}\r\n\r\nclass RecipeEditor extends React.Component<Props> {\r\n  constructor(props: Props) {\r\n    super(props);\r\n    this.editorType = 'gui';\r\n    this.recipe = props.initialRecipe;\r\n\r\n    //this.recipeText = '';\r\n    this.errorText = null;\r\n\r\n    this.playlistsAlphabetical = null;\r\n    (async () => {\r\n      this.playlistsAlphabetical = await api.getPlaylists();\r\n      this.setState({\r\n        playlistsAlphabetical: this.playlistsAlphabetical\r\n      });\r\n    })();\r\n  }\r\n\r\n  playlistsAlphabetical: Array<SpotifyApi.PlaylistObjectSimplified>|null;\r\n  editorType: 'gui'|'text';\r\n  recipe: Recipe;\r\n\r\n  renderGui(): JSX.Element {\r\n    return (\r\n      <div>\r\n        <div>\r\n          {this.playlistsAlphabetical\r\n            ? <div>\r\n                <div className=\"border\">\r\n                  <span>Name: </span>\r\n                  <input\r\n                    value={this.recipe.name}\r\n                    onChange={event => this.handleNameChanged(event.target.value)}\r\n                    />\r\n                </div>\r\n                <div className=\"border\">\r\n                  <span>Target output playlist:</span>\r\n                  <SelectSearch\r\n                    value={this.recipe.targetPlaylistId /* TODO convert to name here */}\r\n                    options={this.getPlaylistsAsSelectOptions()}\r\n                    placeholder={\"Choose a playlist\"}\r\n                    search\r\n                    onChange={value => this.handleTargetPlaylistChanged(value)}\r\n                    />\r\n                  <span>id: </span>\r\n                  <input disabled value={this.recipe ? this.recipe.targetPlaylistId : ''}></input>\r\n                </div>\r\n                {this.recipe.steps.map((step, index) => {\r\n                  return <div className=\"border\">\r\n                    <span>Step type:</span>\r\n                    <SelectSearch\r\n                      value={step.operator}\r\n                      options={getStepOperators().map(operator => {\r\n                        return {name: operator, value: operator};\r\n                      })}\r\n                      onChange={value => this.handleStepTypeModified(index, value)}\r\n                      />\r\n                    {this.renderGuiStepOperators(step, index)}\r\n                  </div>\r\n                })}\r\n                <div className=\"border\">\r\n                  <button onClick={() => this.handleAddNewStep()}>Add a new step</button>\r\n                </div>\r\n              </div>\r\n            : <span>Loading playlists...</span>}\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n  renderGuiStepOperators(step: Step, index: number): JSX.Element|null {\r\n    switch (step.operator) {\r\n      case 'appendPlaylistById':\r\n      case 'filterByPlaylistId':\r\n        return <div>\r\n            <span>Playlist to append:</span>\r\n            <SelectSearch\r\n              value={step.operands[0]}\r\n              options={this.getPlaylistsAsSelectOptions()}\r\n              placeholder={\"Choose a playlist\"}\r\n              search\r\n              onChange={value => this.handleAppendStepModified(index, value)}\r\n              />\r\n          </div>;\r\n\r\n\r\n      case 'filterBySavedTracks':\r\n        return null;\r\n\r\n      default:\r\n        return <span>{'unknown: ' + step.operator}</span>;\r\n    }\r\n  }\r\n  handleNameChanged(newName: string) {\r\n    this.recipe.name = newName;\r\n    this.recipeChanged();\r\n  }\r\n  handleTargetPlaylistChanged(value: any) {\r\n    if (Array.isArray(value)) {\r\n      console.error('selected option is an array?', value);\r\n      return;\r\n    }\r\n    if (typeof value !== 'string') {\r\n      console.error('selected option is not a string:', value);\r\n      return;\r\n    }\r\n\r\n    this.recipe.targetPlaylistId = value;\r\n    this.recipeChanged();\r\n  }\r\n  handleStepTypeModified(stepIndex: number, value: any) {\r\n    if (typeof value !== 'string') {\r\n      console.error('selected option is not a sring:', value);\r\n      return;\r\n    }\r\n    this.recipe.steps[stepIndex].operator = (value as StepOperator);\r\n    this.recipe.steps[stepIndex].operands = [];\r\n    this.recipeChanged();\r\n  }\r\n  handleAddNewStep() {\r\n    this.recipe.steps.push({operator: 'appendPlaylistById', operands: ['playlistId']});\r\n    this.recipeChanged();\r\n    console.log('added step', this);\r\n  }\r\n  handleAppendStepModified(stepIndex: number, value: any) {\r\n    if (typeof value !== 'string') {\r\n      console.error('handleAppendStepModified value isnt a string:', value);\r\n      return;\r\n    }\r\n    this.recipe.steps[stepIndex].operands[0] = value;\r\n    this.recipeChanged();\r\n  }\r\n  getPlaylistsAsSelectOptions() {\r\n    if (!this.playlistsAlphabetical) {\r\n      console.error('getSelectOptions this.playlistsAlphabetical hasnt loaded yet!', this);\r\n      return [];\r\n    }\r\n    const options = [];\r\n    for (const playlist of this.playlistsAlphabetical) {\r\n      options.push({\r\n        name: playlist.name,\r\n        value: playlist.id\r\n      });\r\n    }\r\n    return options;\r\n  }\r\n\r\n\r\n\r\n  // TODO figure out how to put this in a separate component\r\n  //recipeText: string;\r\n  errorText: string|null;\r\n  renderText(): JSX.Element {\r\n    console.log('this.errortext: ',this.errorText);\r\n    return (\r\n      <div>\r\n        <textarea\r\n          defaultValue={JSON.stringify(this.recipe, null, 2)}\r\n          onChange={(event) => this.handleRenderTextChange(event)}\r\n          cols={60}\r\n          rows={30} />\r\n        {this.errorText ? <div className=\"error\">error: {this.errorText}</div> : ''}\r\n      </div>\r\n    );\r\n  }\r\n  handleRenderTextChange(event: React.ChangeEvent<HTMLTextAreaElement>) {\r\n    //this.recipeText = event.target.value;\r\n    const parsedRecipe = parseRecipe(event.target.value);\r\n    console.log('parsedRecipe:', parsedRecipe);\r\n    if (typeof parsedRecipe === 'string') {\r\n      // TODO why tf isn't setState working anymore\r\n      this.errorText = parsedRecipe;\r\n      this.setState({errorText: parsedRecipe});\r\n    } else {\r\n      this.errorText = null;\r\n      this.setState({errorText: null});\r\n      this.recipe = parsedRecipe;\r\n      this.recipeChanged();\r\n    }\r\n  }\r\n\r\n  setEditorType(type: 'gui'|'text') {\r\n    this.editorType = type;\r\n    this.setState({\r\n      editorType: this.editorType\r\n    });\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <div>\r\n        <div>\r\n          <button\r\n            onClick={this.setEditorType.bind(this, 'gui')}\r\n            disabled={this.editorType === 'gui'}>\r\n            GUI\r\n          </button>\r\n          <button\r\n            onClick={this.setEditorType.bind(this, 'text')}\r\n            disabled={this.editorType === 'text'}>\r\n            Text\r\n          </button>\r\n        </div>\r\n        {this.editorType === 'text' ? this.renderText() : this.renderGui()}\r\n      </div>\r\n    );\r\n  }\r\n\r\n  recipeChanged() {\r\n    this.setState({\r\n      recipe: this.recipe,\r\n    })\r\n    this.props.onRecipeChanged(this.recipe);\r\n    //this.recipeText = JSON.stringify(recipe, null, 2);\r\n  }\r\n}\r\n\r\nexport default RecipeEditor;","import { Recipe } from './Recipe';\r\nimport * as Api from './Api';\r\n\r\nexport async function runRecipe(recipe: Recipe): Promise<Array<SpotifyApi.TrackObjectFull>> {\r\n  let tracks: Array<SpotifyApi.TrackObjectFull> = [];\r\n  for (const step of recipe.steps) {\r\n    switch (step.operator) {\r\n      case 'appendPlaylistById':\r\n        if (!step.operands || !step.operands[0]) {\r\n          throw new Error('invalid step: ' + JSON.stringify(step));\r\n        }\r\n        const playlistId = step.operands[0];\r\n        tracks = tracks.concat((await Api.getTracksForPlaylistId(playlistId))\r\n          .map(track => track.track));\r\n        break;\r\n      \r\n      case 'filterByPlaylistId':\r\n        if (!step.operands || !step.operands[0]) {\r\n          throw new Error('invalid step: ' + JSON.stringify(step));\r\n        }\r\n        const includedTrackIds = (await Api.getTracksForPlaylistId(step.operands[0])).map(track => track.track.id);\r\n        tracks = tracks.filter(track => includedTrackIds.includes(track.id));\r\n        break;\r\n\r\n      case 'filterBySavedTracks':\r\n        const likedTrackIds = (await Api.getSavedTracks()).map(track => track.track.id);\r\n        tracks = tracks.filter(track => likedTrackIds.includes(track.id));\r\n        break;\r\n\r\n      default:\r\n        throw new Error('unrecognized operator: ' + step.operator);\r\n    }\r\n  }\r\n  return tracks;\r\n}","import React from 'react';\nimport './App.css';\nimport SplitWidget from './SplitWidget';\nimport RecipeEditor from './RecipeEditor';\nimport { Recipe } from './Recipe';\nimport EmptyWidget from './EmptyWidget';\nimport ConsoleOutput from './ConsoleOutput';\nimport { runRecipe } from './RecipeRunner';\nimport { pushToPlaylist } from './Api';\n\nclass App extends React.Component {\n  constructor(props: {}) {\n    super(props);\n    this.currentEditor = null;\n    this.recipes = [];\n    this.currentRecipeIndex = -1;\n    this.consoleLines = [];\n    this.recipesServer = localStorage.getItem('recipesServer') || '';\n    this.recipesDirty = false;\n  }\n\n  currentEditor: JSX.Element|null = null;\n  currentRecipeIndex: number;\n  recipes: Array<Recipe>;\n  consoleLines: Array<string>;\n  recipesServer: string;\n  recipesDirty: boolean;\n\n  newRecipe() {\n    this.setState({\n      recipes: this.recipes.push({\n        name: 'my-new-recipe',\n        targetPlaylistId: 'playlistId',\n        steps: []\n      })\n    });\n  }\n\n  handleRecipeChanged(newRecipe: Recipe) {\n    this.recipes[this.currentRecipeIndex] = newRecipe;\n    this.setState({\n      recipes: this.recipes\n    });\n    this.recipesDirty = true;\n  }\n\n  handleEditRecipe(recipe: Recipe, index: number) {\n    const newEditor = <RecipeEditor\n        initialRecipe={recipe}\n        onRecipeChanged={this.handleRecipeChanged.bind(this)} />\n    console.log('newEditor:', newEditor);\n    this.currentEditor = newEditor;\n    this.currentRecipeIndex = index;\n    // TODO why doesn't setState here actually change this.currentEditor??\n    this.setState({\n      currentEditor: newEditor,\n      currentRecipeIndex: index\n    });\n  }\n\n  async handleRunRecipe(recipe: Recipe) {\n    console.log('running recipe...', recipe);\n    const tracks = await runRecipe(recipe);\n    console.log('finished running recipe', recipe);\n    await pushToPlaylist(recipe.targetPlaylistId, tracks);\n  }\n\n  handleDeleteRecipe(index: number) {\n    if (window.confirm('Are you sure you want to delete \"' + this.recipes[index].name + '\"?')) {\n      if (this.currentRecipeIndex === index) {\n        this.currentRecipeIndex = -1;\n        this.currentEditor = null;\n      }\n      this.recipes.splice(index, 1);\n      console.log('deleting recipe', this);\n      this.setState({\n        recipes: this.recipes,\n        currentRecipeIndex: this.currentRecipeIndex,\n        currentEditor: this.currentRecipeIndex\n      });\n    }\n  }\n\n  render() {\n    console.log('render this.currentEditor', this.currentEditor);\n    return (\n      <div>\n        <SplitWidget>\n          {this.renderRecipesList()}\n          {this.currentEditor\n            ? this.currentEditor\n            : /*<EmptyWidget message=\"Select a recipe from the sidebar\" />*/''}\n        </SplitWidget>\n        <div className=\"border\">\n          <h3>Settings</h3>\n          <div>\n            <span>Recipes server (optional):</span>\n            <input\n              value={this.recipesServer}\n              onChange={event => this.recipesServerChanged(event.target.value)}\n              />\n            <button onClick={() => this.pushToRecipesServer()}>Save{this.recipesDirty ? '*' : ''}</button>\n            <button onClick={() => this.loadFromRecipesServer()}>Load</button>\n          </div>\n        </div>\n      </div>\n    );\n    // TODO use this <ConsoleOutput lines={this.consoleLines} />\n  }\n\n  recipesServerChanged(newServer: string) {\n    localStorage.setItem('recipesServer', newServer);\n    this.recipesServer = newServer;\n    this.setState({recipesServer: this.recipesServer});\n  }\n\n  async loadFromRecipesServer() {\n    if (!this.recipesServer)\n      return;\n\n    const response = await fetch(this.recipesServer);\n    if (!response.ok) {\n      console.error('loadFromRecipesServer fetch failed:', response);\n      return;\n    }\n\n    const json = await response.json();\n    this.recipes = json;\n    this.setState({\n      recipes: this.recipes\n    });\n    console.log('loaded new recipes:', json, response);\n  }\n\n  async pushToRecipesServer() {\n    if (!this.recipesServer)\n      return;\n\n    this.recipesDirty = false;\n    this.setState({\n      recipesDirty: this.recipesDirty\n    });\n\n    const response = await fetch(this.recipesServer, {\n      method: 'POST',\n      headers: {\n        'content-type': 'application/json'\n      },\n      mode: 'cors',\n      body: JSON.stringify(this.recipes, null, 2)\n    });\n\n    if (!response.ok)\n      console.error('recipe server fetch failed:', response);\n  }\n\n  renderRecipesList() {\n    return (\n      <div>\n        <div>TODO run all recipes button</div>\n        <button onClick={() => this.newRecipe()}>New recipe</button>\n        <ul>\n          {this.recipes.map((recipe, index) => {\n            return (\n              <li>\n                {recipe.name}\n                <div>\n                  <button onClick={this.handleEditRecipe.bind(this, recipe, index)}>Edit</button>\n                  <button onClick={this.handleRunRecipe.bind(this, recipe)}>Run</button>\n                  <button onClick={this.handleDeleteRecipe.bind(this, index)}>Delete</button>\n                </div>\n              </li>\n            );\n          })}\n        </ul>\n      </div>\n    );\n  }\n}\n\nexport default App;","import React from 'react';\r\n\r\nclass Login extends React.Component {\r\n  constructor(props: {}) {\r\n    super(props);\r\n    this.state = {\r\n      clientId: localStorage.getItem('clientId') || ''\r\n    }\r\n  }\r\n\r\n  state: {\r\n    clientId: string;\r\n  }\r\n\r\n  handleClientIdChange(event: React.ChangeEvent<HTMLInputElement>) {\r\n    const newClientId = event.target.value;\r\n    this.setState({clientId: newClientId});\r\n    localStorage.setItem('clientId', newClientId);\r\n  }\r\n\r\n  handleLogin() {\r\n    if (!this.state.clientId) {\r\n      alert('Client ID is required');\r\n      return;\r\n    }\r\n\r\n    const scope = [\r\n      'ugc-image-upload',\r\n      'user-read-playback-state',\r\n      'user-modify-playback-state',\r\n      'user-read-currently-playing',\r\n      'streaming',\r\n      'app-remote-control',\r\n      'user-read-email',\r\n      'user-read-private',\r\n      'playlist-read-collaborative',\r\n      'playlist-modify-public',\r\n      'playlist-read-private',\r\n      'playlist-modify-private',\r\n      'user-library-modify',\r\n      'user-library-read',\r\n      'user-top-read',\r\n      'user-read-playback-position',\r\n      'user-read-recently-played',\r\n      'user-follow-read',\r\n      'user-follow-modify'\r\n    ].join(' ');\r\n\r\n    window.location.href = `https://accounts.spotify.com/authorize`\r\n      + `?response_type=token`\r\n      + `&client_id=${encodeURIComponent(this.state.clientId)}`\r\n      + `&scope=${scope}`\r\n      + `&redirect_uri=${encodeURIComponent(window.location.origin + '/')}`;\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <div>\r\n        <label htmlFor=\"clientId\">Client ID</label>\r\n        <input name=\"clientId\" value={this.state.clientId} onChange={this.handleClientIdChange.bind(this)}></input>\r\n        <div>\r\n          <button onClick={this.handleLogin.bind(this)}>Login</button>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Login;","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\nimport Login from './Login';\nimport * as Api from './Api';\n\n(async () => {\n  // for some reason, the spotify api redirecting uses hash instead of query string...\n  let queryString = window.location.search;\n  if (!queryString.includes('access_token') && window.location.hash.includes('access_token')) {\n    queryString = window.location.hash.replace('#', '?');\n  }\n  const urlParams = new URLSearchParams(queryString);\n  const accessToken = urlParams.get('access_token');\n  const tokenType = urlParams.get('token_type');\n  const expires_in = urlParams.get('expires_in'); // TODO use this\n\n  // TODO look in localStorage for an accessToken?\n  console.log('accessToken: ' + accessToken);\n\n  if (!accessToken || !await Api.setAccessToken(accessToken)) {\n    ReactDOM.render(\n      <React.StrictMode>\n        <Login />\n      </React.StrictMode>,\n      document.getElementById('root')\n    );\n    return;\n  }\n\n  ReactDOM.render(\n    <React.StrictMode>\n      <App />\n    </React.StrictMode>,\n    document.getElementById('root')\n  );\n})();\n\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\n//reportWebVitals();"],"sourceRoot":""}